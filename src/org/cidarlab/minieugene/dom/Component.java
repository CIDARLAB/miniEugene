/*
Copyright (c) 2014 Boston University.
All rights reserved.
Permission is hereby granted, without written agreement and without
license or royalty fees, to use, copy, modify, and distribute this
software and its documentation for any purpose, provided that the above
copyright notice and the following two paragraphs appear in all copies
of this software.

IN NO EVENT SHALL BOSTON UNIVERSITY BE LIABLE TO ANY PARTY
FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
BOSTON UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

BOSTON UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND BOSTON UNIVERSITY HAS
NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
ENHANCEMENTS, OR MODIFICATIONS.
 */

package org.cidarlab.minieugene.dom;

import org.cidarlab.minieugene.constants.Type;
import org.cidarlab.minieugene.solver.jacop.PartTypes;

/**
 * A Component represents a rule operand in miniEugene. From a biology perspective, 
 * a component can either be a nucleotide, part, device, or systems. 
 * I.e. components are agnostic to the level of abstraction.
 * <p>
 * A component is characterized by four attributes:<br/>
 * - an integer ID (generated by miniEugene)<br/>
 * - a unique name<br/>
 * - a type<br/>
 * - direction (forward/reverse)<br/>
 * <p>
 * The type is automatically derived from the first character of the component's name (not case-sensitive).<br/>
 * p: Promoter, r: RBS, c or g: Gene, t: Terminator<br/>
 * For example, naming a rule operand pTet, miniEugene will infer that pTet is a Promoter.<br/>
 * Also, every type has a unique ID and a name.
 * <p>
 * @author Ernst Oberortner
 */
public class Component 
		extends NamedElement {

	private static final long serialVersionUID = 7540207737327161186L;

	/*
	 * id
	 */
	private int id;
	
	/*
	 * direction
	 */
	private boolean forward;
	
	
	public Component(String name) {
		super(name);
		this.forward = true;

		this.id = hash(this.getName());
	}
	
	public Component(String name, boolean forward) {
		super(name);
		this.forward = forward;
		
		this.id = hash(this.getName());
	}
	
	private int hash(String name) {
		int hash = name.hashCode();
		if(hash < 0) {
			return hash * -1;
		}
		return hash;
	}
	
	/**
	 * isForward/0 returns true if the symbol's orientation is forward, 
	 * false otherwise. 
	 * 
	 * @return true    if the symbol has a forward orientation
	 *         false   otherwise
	 */
	public boolean isForward() {
		return forward;
	}
	
	/**
	 * setForward/1 is used by miniEugene internally to set the 
	 * correct orientation of a symbol in a solution.
	 * <p> 
	 * It is up to you to change the orientation of a symbol while 
	 * processing the solutions.
	 *  
	 * @param forward <br/>
	 * true if the symbol is forward oriented<br/>
	 * false, otherwise
	 */
	public void setForward(boolean forward) {
		this.forward = forward;
	}

	/**
	 * getID/0 returns the ID of the symbol
	 * 
	 * @return int ... the automatically generated ID of the symbol
	 */
	public int getId() {
		return this.id;
	}

	/**
	 * getTypeId/0 returns the type's ID of the component
	 * 
	 * 1 ... Promoter
	 * 2 ... RBS
	 * 3 ... Gene
	 * 4 ... Terminator
	 * 5 ... otherwise
	 * 
	 * @return int ... the type's ID
	 */
	public int getTypeId() {
		if('p' == this.getName().charAt(0) || 'P' == this.getName().charAt(0)) {
			return PartTypes.get("PROMOTER");
		} else if('r' == this.getName().charAt(0) || 'R' == this.getName().charAt(0)) {
			return PartTypes.get("RBS");  
		} else if('c' == this.getName().charAt(0) || 'C' == this.getName().charAt(0) ||
				'g' == this.getName().charAt(0) || 'G' == this.getName().charAt(0)) {
			return PartTypes.get("GENE");  
		} else if('t' == this.getName().charAt(0) || 'T' == this.getName().charAt(0)) {
			return PartTypes.get("TERMINATOR");  
		} 
		return 5;
	}
	
	/**
	 * the getTypeName method returns the component's type name derived 
	 * from the first character of the name of the component.
	 * 
	 * p|P     ... Promoter
	 * r|R     ... RBS
	 * c|g|C|G ... Gene
	 * t|T     ... Terminator
	 *  
	 * @return the name of the component's type
	 */
	public String getTypeName() {
		if('p' == this.getName().charAt(0) || 'P' == this.getName().charAt(0)) {
			return "PROMOTER";
		} else if('r' == this.getName().charAt(0) || 'R' == this.getName().charAt(0)) {
			return  "RBS";  
		} else if('c' == this.getName().charAt(0) || 'C' == this.getName().charAt(0) ||
				'g' == this.getName().charAt(0) || 'G' == this.getName().charAt(0)) {
			return "GENE";  
		} else if('t' == this.getName().charAt(0) || 'T' == this.getName().charAt(0)) {
			return "TERMINATOR";  
		} 
		return "?";
		
	}
	
	/**
	 * returns the type of the component
	 * 
	 * @return
	 */
	public Type getType() {
		if(this.getName().toUpperCase().startsWith("P")) {
			return Type.PROMOTER;
		} else if(this.getName().toUpperCase().startsWith("R")) {
			return Type.RIBOSOME_BINDING_SITE;
		} else if(this.getName().toUpperCase().startsWith("C") ||
				this.getName().toUpperCase().startsWith("G")) {
			return Type.CODING_SEQUENCE;
		} else if(this.getName().toUpperCase().startsWith("T")) {
			return Type.TERMINATOR;
		}
		return Type.UNKNOWN;
	}
	
	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("{").append(this.getId()).append(", ").append(this.getName()).append(", ");
		if(this.isForward()) {
			sb.append("->");
		} else {
			sb.append("<-");
		}
		sb.append("}");
		return sb.toString();
	}
}
