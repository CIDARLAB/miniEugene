/*
Copyright (c) 2014 Boston University.
All rights reserved.
Permission is hereby granted, without written agreement and without
license or royalty fees, to use, copy, modify, and distribute this
software and its documentation for any purpose, provided that the above
copyright notice and the following two paragraphs appear in all copies
of this software.

IN NO EVENT SHALL BOSTON UNIVERSITY BE LIABLE TO ANY PARTY
FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
BOSTON UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

BOSTON UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND BOSTON UNIVERSITY HAS
NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
ENHANCEMENTS, OR MODIFICATIONS.
 */

package org.cidarlab.minieugene.dom;

import org.cidarlab.minieugene.constants.PartTypesTable;

/**
 * A Component represents a rule operand in miniEugene. From a biology perspective, 
 * a component can either be a nucleotide, part, device, or systems. 
 * I.e. components are agnostic to the level of abstraction.
 * <p>
 * A component is characterized by four attributes:<br/>
 * - an integer ID (generated by miniEugene)<br/>
 * - a unique name<br/>
 * - a type<br/>
 * - direction (forward/reverse)<br/>
 * <p>
 * The type is automatically derived from the first character of the component's name (not case-sensitive).<br/>
 * p: Promoter, r: RBS, c or g: Gene, t: Terminator<br/>
 * For example, naming a rule operand pTet, miniEugene will infer that pTet is a Promoter.<br/>
 * Also, every type has a unique ID and a name.
 * <p>
 * @author Ernst Oberortner
 */
public class Component 
		extends NamedElement {

	private static final long serialVersionUID = 7540207737327161186L;

	/*
	 * id
	 */
	private int id;
	
	/*
	 * orientation
	 */
	private boolean forward;
	
	/*
	 * part type
	 */
	private PartTypesTable.PartType pt;
	
	
	public Component(String name) {
		super(name);		
		this.forward = true;
		this.id = hash(this.getName());
		this.pt = PartTypesTable.toPartType(this.getName());
	}
	
	public Component(String name, boolean forward) {
		super(name);
		this.forward = forward;		
		this.id = hash(this.getName());
		this.pt = PartTypesTable.toPartType(this.getName());
	}
	
	// to convert the name to an integer
	// for the constraint solver.
	// NEEDS IMPROVEMENT!
	private int hash(String name) {
		int hash = name.hashCode();
		if(hash < 0) {
			return hash * -1;
		}
		return hash;
	}
	
	/**
	 * isForward/0 returns true if the symbol's orientation is forward, 
	 * false otherwise. 
	 * 
	 * @return true    if the symbol has a forward orientation
	 *         false   otherwise
	 */
	public boolean isForward() {
		return forward;
	}
	
	/**
	 * setForward/1 is used by miniEugene internally to set the 
	 * correct orientation of a symbol in a solution.
	 * <p> 
	 * It is up to you to change the orientation of a symbol while 
	 * processing the solutions.
	 *  
	 * @param forward <br/>
	 * true if the symbol is forward oriented<br/>
	 * false, otherwise
	 */
	public void setForward(boolean forward) {
		this.forward = forward;
	}

	/**
	 * getID/0 returns the ID of the symbol
	 * 
	 * @return int ... the automatically generated ID of the symbol
	 */
	public int getId() {
		return this.id;
	}

	/**
	 * getTypeId/0 returns the type's ID of the component. 
	 * This method is only relevant for the constraint solver.
	 * 
	 * 1 ... Promoter
	 * 2 ... RBS
	 * 3 ... Gene
	 * 4 ... Terminator
	 * 5 ... otherwise
	 * 
	 * @return int ... the type's ID
	 */
	public int getTypeId() {		
		return PartTypesTable.toId(this.pt);
	}
	
	/**
	 * the getTypeName method returns the component's type name derived 
	 * from the first two characters of the name of the component.
	 *  
	 * @return the name of the component's type
	 */
	public String getTypeName() {
		String s = PartTypesTable.toName(this.pt);
		if(null == s) {
			return "?";
		}
		return s;		
	}
	
	/**
	 * returns the type of the component as a 
	 * two character long string
	 * 
	 * @return
	 */
	private PartTypesTable.PartType getPartType() {
		return this.pt;
	}
	
	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("{")
			.append(this.getId()).append(", ")          // ID
			.append(this.getPartType()).append(", ")    // PART TYPE
			.append(this.getName()).append(", ");       // PART NAME
		if(this.isForward()) {                          // ORIENTATION
			sb.append("->");
		} else {
			sb.append("<-");
		}
		sb.append("}");
		return sb.toString();
	}
}
