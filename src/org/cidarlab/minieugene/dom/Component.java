/*
 * Copyright (c) 2014, Boston University
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following 
 * conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *    
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in 
 *    the documentation and/or other materials provided with the distribution.
 *    
 * 3. Neither the name of the copyright holder nor the names of its 
 *    contributors may be used to endorse or promote products derived 
 *    from this software without specific prior written permission.
 *    
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED 
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.cidarlab.minieugene.dom;

import org.cidarlab.minieugene.constants.PartTypesTable;

/**
 * A Component represents a rule operand in miniEugene. From a biology perspective, 
 * a component can either be a nucleotide, part, device, or systems. 
 * I.e. components are agnostic to the level of abstraction.
 * <p>
 * A component is characterized by four attributes:<br/>
 * - an integer ID (generated by miniEugene)<br/>
 * - a unique name<br/>
 * - a type<br/>
 * - direction (forward/reverse)<br/>
 * <p>
 * The type is automatically derived from the first character of the component's name (not case-sensitive).<br/>
 * p: Promoter, r: RBS, c or g: Gene, t: Terminator<br/>
 * For example, naming a rule operand pTet, miniEugene will infer that pTet is a Promoter.<br/>
 * Also, every type has a unique ID and a name.
 * <p>
 * @author Ernst Oberortner
 */
public class Component 
		extends NamedElement {

	private static final long serialVersionUID = 7540207737327161186L;

	/*
	 * id
	 */
	private int id;
	
	/*
	 * orientation
	 */
	private boolean forward;
	
	/*
	 * part type
	 */
	private PartTypesTable.PartType pt;
	
	/*
	 * type
	 */
	private ComponentType type;
	
	public Component(String name, ComponentType type) {
		// name
		super(name);
		// type
		this.type = type;
		// orientation
		this.forward = true;
		// id
		this.id = hash(this.getName());
	}
	
	public Component(String name) {
		super(name);		
		this.forward = true;
		this.id = hash(this.getName());
		this.pt = PartTypesTable.toPartType(this.getName());
	}
	
	public Component(String name, boolean forward) {
		super(name);
		this.forward = forward;		
		this.id = hash(this.getName());
		this.pt = PartTypesTable.toPartType(this.getName());
	}
	
	// to convert the name to an integer
	// for the constraint solver.
	// NEEDS IMPROVEMENT!
	private int hash(String name) {
		int hash = name.hashCode();
		if(hash < 0) {
			return hash * -1;
		}
		return hash;
	}
	
	/**
	 * isForward/0 returns true if the symbol's orientation is forward, 
	 * false otherwise. 
	 * 
	 * @return true    if the symbol has a forward orientation
	 *         false   otherwise
	 */
	public boolean isForward() {
		return forward;
	}
	
	/**
	 * setForward/1 is used by miniEugene internally to set the 
	 * correct orientation of a symbol in a solution.
	 * <p> 
	 * It is up to you to change the orientation of a symbol while 
	 * processing the solutions.
	 *  
	 * @param forward <br/>
	 * true if the symbol is forward oriented<br/>
	 * false, otherwise
	 */
	public void setForward(boolean forward) {
		this.forward = forward;
	}

	/**
	 * getID/0 returns the ID of the symbol
	 * 
	 * @return int ... the automatically generated ID of the symbol
	 */
	public int getId() {
		return this.id;
	}

	/**
	 * getTypeId/0 returns the type's ID of the component. 
	 * This method is only relevant for the constraint solver.
	 * 
	 * 1 ... Promoter
	 * 2 ... RBS
	 * 3 ... Gene
	 * 4 ... Terminator
	 * 5 ... otherwise
	 * 
	 * @return int ... the type's ID
	 */
	public int getTypeId() {		
		return PartTypesTable.toId(this.pt);
	}
	
	/**
	 * the getTypeName method returns the component's type name derived 
	 * from the first two characters of the name of the component.
	 *  
	 * @return the name of the component's type
	 */
	public String getTypeName() {
		String s = PartTypesTable.toName(this.pt);
		if(null == s) {
			return "?";
		}
		return s;		
	}
	
	/**
	 * returns the type of the component as a 
	 * two character long string
	 * 
	 * @return
	 */
	private PartTypesTable.PartType getPartType() {
		return this.pt;
	}
	
	/**
	 * the getType/0 method returns the type 
	 * of the component as object
	 * 
	 * @return ... the ComponentType object representing
	 *             the type of this component
	 */
	public ComponentType getType() {
		return this.type;
	}
	
	/**
	 * the setType/1 method takes as input the type of the component
	 * and sets the type of the component to the given type.
	 * if the type of the component is already is, then the current 
	 * type will be overwritten.
	 * 
	 * we need this method since the type specifications can happen 
	 * after the constraint specifications.
	 * 
	 * Example: imagine the following miniEugene script
	 * contains p. p is_a promoter.
	 * 
	 * the type of p is specified after p has been declared.
	 * 
	 * @param type ... the type of the component
	 */
	public void setType(ComponentType type) {
		this.type = type;
	}
	
	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("{")
			.append(this.getId()).append(", ");          // ID
		
		if(null != this.getType()) {
			sb.append(this.getType()).append(", ");    	// TYPE
		} else {
			sb.append(PartTypesTable.toName(
					this.getPartType())).append(", ");
		}
		
		sb.append(this.getName()).append(", ");         // NAME
		
		if(this.isForward()) {                          // ORIENTATION
			sb.append("->");
		} else {
			sb.append("<-");
		}
		sb.append("}");
		return sb.toString();
	}
}
